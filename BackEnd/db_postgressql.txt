CREATE DATABASE supplier;

-- ========================================
-- Tabla: state
-- ========================================
CREATE TABLE state (
    id           BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name         VARCHAR(40) NOT NULL,
    code         CHAR(2) NOT NULL,
    created_at   TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at   TIMESTAMP NOT NULL DEFAULT NOW(),

    CONSTRAINT uq_state_code UNIQUE (code),
    CONSTRAINT uq_state_name UNIQUE (name)

);

CREATE INDEX idx_state_name ON state (name);


-- ========================================
-- Tabla: county
-- ========================================
CREATE TABLE county (
    id          BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    state_id    BIGINT NOT NULL,
    name        VARCHAR(40) NOT NULL,
    code   	CHAR(3) NOT NULL,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT fk_county_state
        FOREIGN KEY (state_id) REFERENCES state(id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,

    CONSTRAINT uq_county_name_per_state UNIQUE (state_id, name)
);

CREATE INDEX idx_county_state_id ON county (state_id);

-- ========================================
-- Tabla: customer
-- ========================================
CREATE TABLE customer (
    id               BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nit		     VARCHAR(20) NOT NULL UNIQUE,
    first_name       VARCHAR(50) NOT NULL,
    middle_name      VARCHAR(50),
    last_name        VARCHAR(50) NOT NULL,
    second_last_name VARCHAR(50),
    email            VARCHAR(120) UNIQUE,
    phone            VARCHAR(30),
    address          VARCHAR(150),
    county_id	     BIGINT NOT NULL,
    created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT uq_customer_nit UNIQUE (nit),
    CONSTRAINT uq_customer_email UNIQUE (email),

    CONSTRAINT fk_customer_county
        	FOREIGN KEY (county_id) REFERENCES county(id)
	        ON UPDATE CASCADE
		ON DELETE RESTRICT

);

CREATE INDEX idx_customer_county ON customer (county_id);

-- ========================================
-- Carga audit_logs 
-- ========================================

CREATE TABLE "user" (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(150) NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    full_name VARCHAR(150) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE role (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE user_role (
    user_id BIGINT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    role_id BIGINT NOT NULL REFERENCES role(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, role_id),
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

INSERT INTO role (name, description) VALUES
('admin', 'Acceso total al sistema'),
('accounting', 'Gestiona facturas y pagos'),
('supplier_admin', 'Gestiona proveedores'),
('viewer', 'Solo lectura');

CREATE TABLE permission (
    id BIGSERIAL PRIMARY KEY,
    code VARCHAR(100) NOT NULL UNIQUE,       -- invoice.read, invoice.create, supplier.update
    description TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

INSERT INTO permission (code, description) VALUES
('invoice.read', 'Ver facturas'),
('invoice.create', 'Crear facturas'),
('invoice.update', 'Editar facturas'),
('invoice.delete', 'Eliminar facturas'),

('supplier.read', 'Ver proveedores'),
('supplier.create', 'Crear proveedores'),
('supplier.update', 'Editar proveedores'),
('supplier.delete', 'Eliminar proveedores'),

('payment.process', 'Aprobar y procesar pagos');

CREATE TABLE role_permission (
    role_id BIGINT NOT NULL REFERENCES role(id) ON DELETE CASCADE,
    permission_id BIGINT NOT NULL REFERENCES permission(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id),
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Todos los permisos para admin
INSERT INTO role_permission (role_id, permission_id)
SELECT (SELECT id FROM role WHERE name='admin'), p.id
FROM permission p;

-- Contable solo facturas y pagos
INSERT INTO role_permission (role_id, permission_id)
SELECT (SELECT id FROM role WHERE name='accounting'), id
FROM permission 
WHERE code LIKE 'invoice.%' OR code='payment.process';

-- Solo proveedores
INSERT INTO role_permission (role_id, permission_id)
SELECT (SELECT id FROM role WHERE name='supplier_admin'), id
FROM permission 
WHERE code LIKE 'supplier.%';

-- Solo lectura viewer
INSERT INTO role_permission (role_id, permission_id)
SELECT (SELECT id FROM role WHERE name='viewer'), id
FROM permission 
WHERE code LIKE '%.read';

CREATE TABLE invoice (
    id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL REFERENCES customer(id),
    total NUMERIC(14,2) NOT NULL,
    status VARCHAR(20) NOT NULL,            -- pending, paid, cancelled
    created_by BIGINT NOT NULL REFERENCES "user"(id),
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES "user"(id),
    action VARCHAR(50) NOT NULL,               -- update, delete, create
    entity VARCHAR(100) NOT NULL,              -- invoice, supplier, user, etc.
    entity_id BIGINT NOT NULL,
    old_data JSONB,                            -- Cómo estaba ANTES
    new_data JSONB,                            -- Cómo quedó DESPUÉS
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);



-- ========================================
-- Carga masiva 
-- ========================================

--- insercion masiva de estados
COPY state(code,name)
FROM 'C:\ProveedorWeb\BackEnd\data_excell\states.csv'
DELIMITER ';'
CSV HEADER;


-- insercion masiva de municipios
copy county(code,name,state_id)
FROM 'C:\ProveedorWeb\BackEnd\data_excell\counties.csv'
DELIMITER ';'
CSV HEADER;







-- ========================================
-- Tabla: city
-- ========================================
CREATE TABLE city (
    id          BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    county_id   BIGINT NOT NULL,
    name        VARCHAR(40) NOT NULL,
    postal_code VARCHAR(10),
    latitude    DECIMAL(10,6),
    longitude   DECIMAL(10,6),
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    CONSTRAINT fk_city_county
        FOREIGN KEY (county_id) REFERENCES county(id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,

    CONSTRAINT uq_city_name_per_county UNIQUE (county_id, name)
);

CREATE INDEX idx_city_county_id ON city (county_id);
CREATE INDEX idx_city_name ON city (name);


-- ========================================
-- Tabla: funcion que será llamada en los trigger para actualiar la fecha despues del UPDATE
-- ========================================

CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ========================================
-- Tabla: trigger para actualiar la fecha despues del UPDATE
-- ========================================

CREATE TRIGGER trg_state_updated_at
BEFORE UPDATE ON state
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- ========================================
-- Tabla: funcion que será llamada en los trigger para actualiar la fecha despues del DELETE
-- ========================================


CREATE OR REPLACE FUNCTION soft_delete()
RETURNS TRIGGER AS $$
BEGIN
    NEW.deleted_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- ========================================
-- Tabla: funcion audit_trigger
-- ========================================

CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    v_entity_id BIGINT;
BEGIN
    -- Obtener el ID del registro; se asume que la PK se llama "id"
    IF TG_OP = 'INSERT' THEN
        v_entity_id := NEW.id;
        INSERT INTO audit_log(user_id, action, entity, entity_id, old_data, new_data)
        VALUES (current_setting('app.current_user_id', true)::BIGINT,
                TG_OP,
                TG_TABLE_NAME,
                v_entity_id,
                NULL,
                to_jsonb(NEW));
        RETURN NEW;
        
    ELSIF TG_OP = 'UPDATE' THEN
        v_entity_id := NEW.id;
        INSERT INTO audit_log(user_id, action, entity, entity_id, old_data, new_data)
        VALUES (current_setting('app.current_user_id', true)::BIGINT,
                TG_OP,
                TG_TABLE_NAME,
                v_entity_id,
                to_jsonb(OLD),
                to_jsonb(NEW));
        RETURN NEW;
        
    ELSIF TG_OP = 'DELETE' THEN
        v_entity_id := OLD.id;
        INSERT INTO audit_log(user_id, action, entity, entity_id, old_data, new_data)
        VALUES (current_setting('app.current_user_id', true)::BIGINT,
                TG_OP,
                TG_TABLE_NAME,
                v_entity_id,
                to_jsonb(OLD),
                NULL);
        RETURN OLD;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;



-- ========================================
-- Tabla: trigger en la tabla state que llama a la funcion audit_trigger()
-- ========================================

CREATE TRIGGER trg_audit_state
AFTER INSERT OR UPDATE OR DELETE
ON state
FOR EACH ROW
EXECUTE FUNCTION audit_trigger();


