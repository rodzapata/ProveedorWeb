3. CONFIGURAR JWT AUTH
3.1. ğŸ“ Estructura recomendada:

src/
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ auth.module.ts
â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â”œâ”€â”€ auth.controller.ts
â”‚   â”œâ”€â”€ jwt.strategy.ts
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â””â”€â”€ login.dto.ts
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ user.entity.ts
â”‚   â”œâ”€â”€ users.service.ts
â”‚   â””â”€â”€ users.module.ts

nest g resource auth
nest g resource user

3.2. ğŸ“„ user.entity.ts (ejemplo simple)
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  username: string;

  @Column()
  password: string; // Encriptado con bcrypt
}

3.2.1 Pipe Adicional Necesito que recorte los espacios en blanco en los campos
nest g pipe common/pipes/trim.pipe.ts

ğŸ“ src/common/pipes/trim.pipe.ts
import {
  ArgumentMetadata,
  Injectable,
  PipeTransform,
} from '@nestjs/common';

@Injectable()
export class TrimPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (typeof value !== 'object' || value === null) return value;

    const trimmed = {};
    for (const key in value) {
      const val = value[key];
      trimmed[key] = typeof val === 'string' ? val.trim() : val;
    }

    return trimmed;
  }
}

ğŸ“¦ CÃ³mo usarlo en un controlador
import { Body, Controller, Post } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { TrimPipe } from '../../common/pipes/trim.pipe'; // ruta relativa

@Controller('users')
export class UsersController {
  @Post()
  create(@Body(new TrimPipe()) body: CreateUserDto) {
    // body ya tiene los strings recortados
    return body;
  }
}

ğŸ§  Tip extra
Si quieres aplicar el pipe globalmente a todos los endpoints, tambiÃ©n puedes hacerlo en main.ts:
import { TrimPipe } from './common/pipes/trim.pipe';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new TrimPipe());
  await app.listen(3000);
}



3.3. ğŸ“„ auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async validateUser(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findByUsername(username);
    if (user && await bcrypt.compare(pass, user.password)) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { username: user.username, sub: user.id };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}

3.4. ğŸ“„ jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: 'jwt_secret_key', // debes mover esto a .env
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}

3.5. ğŸ“„ auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './jwt.strategy';
import { AuthController } from './auth.controller';

@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.register({
      secret: 'jwt_secret_key', // usa dotenv
      signOptions: { expiresIn: '1h' },
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}

3.6. ğŸ“„ auth.controller.ts
import { Controller, Post, Body, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    const user = await this.authService.validateUser(loginDto.username, loginDto.password);
    if (!user) {
      throw new UnauthorizedException('Credenciales invÃ¡lidas');
    }
    return this.authService.login(user);
  }
}

3.7. ğŸ“„ login.dto.ts
import { IsString } from 'class-validator';

export class LoginDto {
  @IsString()
  username: string;

  @IsString()
  password: string;
}

3.8. ğŸ“„ users.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private userRepo: Repository<User>,
  ) {}

  async findByUsername(username: string) {
    return this.userRepo.findOne({ where: { username } });
  }
}

3.9. ğŸ”’ Proteger Rutas con JWT
Ejemplo en dpto.controller.ts:
import { UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@UseGuards(JwtAuthGuard)
@Get()
findAll() {
  return this.dptoService.findAll();
}

Crea el guard:
ğŸ“„ auth/jwt-auth.guard.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

ğŸ“ Resultado Final
Visita http://localhost:3000/api

Haz login con POST /auth/login

Copia el access_token

Haz clic en â€œAuthorizeâ€ (en Swagger) y pÃ©galo como: Bearer <token>

Ahora puedes acceder a las rutas protegidas

---------------------------------
Perfecto! A continuaciÃ³n te dejo todo lo que necesitas para:

âœ… Crear un archivo .env con la configuraciÃ³n de JWT y base de datos

âœ… Insertar un usuario de prueba en tu tabla users, con contraseÃ±a encriptada usando bcrypt

âœ… Cargar ese usuario desde el backend NestJS para el login

ğŸ“ 1. Archivo .env
Crea un archivo .env en la raÃ­z del proyecto:

DB_HOST=localhost
DB_PORT=1433
DB_USERNAME=sa
DB_PASSWORD=TuPasswordSegura
DB_DATABASE=NombreDeTuBaseDeDatos

JWT_SECRET=clave_super_secreta
JWT_EXPIRES_IN=3600s

ğŸ“„ 2. Configurar conexiÃ³n a la base de datos con .env
En app.module.ts o donde tengas TypeOrmModule.forRoot():

import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }), // Cargar variables .env
    TypeOrmModule.forRoot({
      type: 'mssql',
      host: process.env.DB_HOST,
      port: parseInt(process.env.DB_PORT, 10),
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_DATABASE,
      synchronize: false,
      entities: [__dirname + '/**/*.entity{.ts,.js}'],
      options: { encrypt: false },
    }),
    // ...
  ],
})

ğŸ” 3. Configurar JwtModule con .env
En auth.module.ts:
JwtModule.register({
  secret: process.env.JWT_SECRET,
  signOptions: { expiresIn: process.env.JWT_EXPIRES_IN },
}),

ğŸ§¾ 4. Crear tabla users (si no existe)
CREATE TABLE users (
  id INT IDENTITY(1,1) PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(100) NOT NULL
);

ğŸ”’ 5. Crear usuario con contraseÃ±a encriptada (bcrypt)
OpciÃ³n 1: Insertar directamente con bcrypt desde Node.js
Crea un script seed-user.ts para insertar el usuario:

import * as bcrypt from 'bcrypt';
import { createConnection } from 'typeorm';
import { User } from './src/users/user.entity';

async function seed() {
  const connection = await createConnection({
    type: 'mssql',
    host: 'localhost',
    port: 1433,
    username: 'sa',
    password: 'TuPasswordSegura',
    database: 'NombreDeTuBaseDeDatos',
    entities: [User],
    synchronize: false,
    options: { encrypt: false },
  });

  const userRepo = connection.getRepository(User);

  const hashedPassword = await bcrypt.hash('admin123', 10);

  const user = userRepo.create({
    username: 'admin',
    password: hashedPassword,
  });

  await userRepo.save(user);
  console.log('Usuario admin creado');

  await connection.close();
}

seed();

Y luego ejecÃºtalo:

ts-node seed-user.ts

ğŸš€ Resultado final
Usuario creado:

username: admin

password: admin123

Puedes hacer POST /auth/login con esos datos y obtener un JWT vÃ¡lido

